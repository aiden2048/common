// Code generated by goctl. DO NOT EDIT.
package {{.PKG}}

import (
   
    "time"
    "context"
	{{if .Expire}}"math/rand"{{end}}
    {{if .Cache}}"fmt"{{else}}{{if .HandPar}}"fmt"{{end}}{{end}}
    "github.com/aiden2048/pkg/public/mongodb"
    "go.mongodb.org/mongo-driver/bson"
	{{if .ImPublicType}}"github.com/aiden2048/common/model/publicType"{{end}}
	"go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/bson/primitive"
)
{{.ConstStr}}
// {{.FileDesc}}
var (
    {{.lowerType}}DbName = "{{.DB}}"
    {{.lowerType}}TbName = "{{.TB}}"
)
// 索引
var {{.lowerType}}IndexKey = []string{
    {{.Index}}
}
var {{.lowerType}}OpIndexKey = []string{
    {{.OpIndex}}
}
var {{.lowerType}}UniqueIndexKey = []string{
    {{.UniqueIndex}}
}
var {{.lowerType}}ExpireIndexKey = []string{
    {{if .Expire}}"expire_at",{{end}}
}

// 表结构

{{.TypeStr}}

type default{{.Type}}ModelFromImage struct{
	Model[{{.Type}}]
}

// New{{.Type}}ModelFromImage returns a model for the mongo image repository.
func New{{.Type}}ModelFromImage({{if .HandPar}}{{.AllPar}}{{end}}) *default{{.Type}}ModelFromImage {
    {{if .HandDbPar}}db := fmt.Sprintf({{.lowerType}}DbName,{{.DbPar}}){{else}}db := {{.lowerType}}DbName{{end}}
    {{if .HandTbPar}}tb := fmt.Sprintf({{.lowerType}}TbName,{{.TbPar}}){{else}}tb := {{.lowerType}}TbName{{end}}
    conn := mongodb.NewMon(db, tb, {{.Cache}},{{.lowerType}}IndexKey,{{.lowerType}}UniqueIndexKey,{{.lowerType}}ExpireIndexKey,ImageRepositoryKey)
	model := &default{{.Type}}ModelFromImage{}
    model.conn = conn
    model.cache = {{.Cache}}
	{{if .NeedLog}}model.NeedLog = true{{end}}

	conn.ReportMongoIndex({{.lowerType}}OpIndexKey, {{.lowerType}}ExpireIndexKey, {{.Version}}, {{.ExpireDay}})
    return model
}

type default{{.Type}}Model struct{
	Model[{{.Type}}]
}

// New{{.Type}}Model returns a model for the mongo.
func New{{.Type}}Model({{if .HandPar}}{{.AllPar}}{{end}}) *default{{.Type}}Model {
    {{if .HandDbPar}}db := fmt.Sprintf({{.lowerType}}DbName,{{.DbPar}}){{else}}db := {{.lowerType}}DbName{{end}}
    {{if .HandTbPar}}tb := fmt.Sprintf({{.lowerType}}TbName,{{.TbPar}}){{else}}tb := {{.lowerType}}TbName{{end}}
    conn := mongodb.NewMon(db, tb, {{.Cache}},{{.lowerType}}IndexKey,{{.lowerType}}UniqueIndexKey,{{.lowerType}}ExpireIndexKey{{if .IsLog}},LogKey{{end}}{{if .Conf}},ConfKey{{end}})
	model := &default{{.Type}}Model{}
    model.conn = conn
    model.cache = {{.Cache}}
	{{if .NeedLog}}model.NeedLog = true{{end}}

	conn.ReportMongoIndex({{.lowerType}}OpIndexKey, {{.lowerType}}ExpireIndexKey,  {{.Version}}, {{.ExpireDay}})
    return model
}

func (m *default{{.Type}}Model) IgnoreConflictInsertOne(ctx context.Context, data *{{.Type}}) error {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero(){
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
	{{if .Expire}}
	if data.ExpireAt.IsZero(){
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		data.ExpireAt = time.Now().Add(({{.ExpireDay}}*24*3600 + 36000+time.Duration(r.Int63n(10800))) * time.Second)
	}
	{{end}}	err := m.conn.IgnoreConflictInsertOne(ctx, data)
	return err
}

func (m *default{{.Type}}Model) InsertOne(ctx context.Context, data *{{.Type}}) error {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero(){
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
	{{if .Expire}}
	if data.ExpireAt.IsZero(){
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		data.ExpireAt = time.Now().Add(({{.ExpireDay}}*24*3600 + 36000+time.Duration(r.Int63n(10800))) * time.Second)
	}
	{{end}}
	err := m.conn.InsertOne(ctx, data)
	return err
}
func (m *default{{.Type}}Model) InsertMany(ctx context.Context, datas []*{{.Type}}) error {
	ins := []any{}
	for _, data := range datas {
		if data.ID.IsZero() {
			data.ID = primitive.NewObjectID()
		}
		if data.CreatedAt.IsZero(){
			data.CreatedAt = time.Now()
		}
		data.UpdatedAt = data.CreatedAt
		{{if .Expire}}
		if data.ExpireAt.IsZero(){
			r:=rand.New(rand.NewSource(time.Now().UnixNano()))
			data.ExpireAt = time.Now().Add(({{.ExpireDay}}*24*3600 + 36000+time.Duration(r.Int63n(10800))) * time.Second)
		}
		{{end}}
		ins = append(ins, data)
	}
	err := m.conn.InsertMany(ctx, ins)
	return err
}

func (m *default{{.Type}}Model) Update(ctx context.Context, data *{{.Type}}) error {
	dataB, err := mongodb.ToBsonM(data)
	if err != nil {
		return err
	}
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOneByID(ctx, dataB["_id"].(primitive.ObjectID).Hex(), &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	{{end}}
	dataB["updated_at"] = time.Now()
	err = m.conn.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}

func (m *default{{.Type}}Model) UpdateOne(ctx context.Context, filter any, data bson.M) error {
	var err error
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOne(ctx, filter, &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	{{end}}
	data["updated_at"] = time.Now()
	err = m.conn.UpdateOne(ctx, filter, bson.M{"$set": data})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}

func (m *default{{.Type}}Model) UpdateMany(ctx context.Context, filter any, data bson.M) error {
	var err error
	{{if .Cache}}
	cacheKeys := []string{}
	var dataMs []bson.M
	cursor, err := m.conn.FindAllV1(ctx, filter)
	if err == nil {
		defer cursor.Close(ctx)
		for cursor.Next(ctx) {
			item := bson.M{}
			err := cursor.Decode(&item)
			if err != nil {
				var tmp bson.M
				cursor.Decode(&tmp)
				continue
			}
			dataMs = append(dataMs, item)
		}
		go func() {
			for _, dataM := range dataMs {

				cacheKeys = append(cacheKeys, fmt.Sprintf("_id.%v", dataM["_id"].(primitive.ObjectID).Hex()))
				cacheKeys = append(cacheKeys, fmt.Sprintf("payoutRef.%v", dataM["payoutRef"]))
			}
		}()
	}
	{{end}}
	data["updated_at"] = time.Now()
	err = m.conn.UpdateMany(ctx, filter, bson.M{"$set": data})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}

func (m *default{{.Type}}Model) UpSert(ctx context.Context, filter any, data bson.M) error {
	var err error
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOne(ctx, filter, &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	{{end}}
	data["updated_at"] = time.Now()
	indata := bson.M{"created_at": time.Now()}
	{{if .Expire}}
	if _,ok:=data["expire_at"];!ok{
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		indata["expire_at"] = time.Now().Add(({{.ExpireDay}}*24*3600 + 36000+time.Duration(r.Int63n(10800))) * time.Second)
	}else{
		indata["expire_at"] = data["expire_at"]
		delete(data,"expire_at")
	}
	{{end}}
	err = m.conn.UpSert(ctx, filter, bson.M{"$set": data,"$setOnInsert": indata})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}

func (m *default{{.Type}}Model) UpInc(ctx context.Context, filter any, data bson.M) error {
	var err error
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOne(ctx, filter, &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	{{end}}
	indata := bson.M{"created_at": time.Now()}
	{{if .Expire}}
	if _,ok:=data["expire_at"];!ok{
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		indata["expire_at"] = time.Now().Add(({{.ExpireDay}}*24*3600 + 36000+time.Duration(r.Int63n(10800))) * time.Second)
	}else{
		indata["expire_at"] = data["expire_at"]
		delete(data,"expire_at")
	}
	{{end}}
	err = m.conn.UpSert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()},"$setOnInsert": indata})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}

func (m *default{{.Type}}Model) UpAndIncWithRes(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	var err error
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOne(ctx, filter, &dataM)
	if err == nil{
		{{.DelCache}}
	}
	{{end}}
	data["updated_at"] = time.Now()
	indata := bson.M{"created_at": time.Now()}
	{{if .Expire}}
	if _,ok:=data["expire_at"];!ok{
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		indata["expire_at"] = time.Now().Add(({{.ExpireDay}}*24*3600 + 36000+time.Duration(r.Int63n(10800))) * time.Second)
	}else{
		indata["expire_at"] = data["expire_at"]
		delete(data,"expire_at")
	}
	{{end}}
	res, err := m.conn.UpSertWithRes(ctx, filter, bson.M{"$set": data, "$inc": incdata,"$setOnInsert": indata})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return res, err
}

func (m *default{{.Type}}Model) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) error {
	var err error
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOne(ctx, filter, &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	{{end}}
	data["updated_at"] = time.Now()
	indata := bson.M{"created_at": time.Now()}
	{{if .Expire}}
	if _,ok:=data["expire_at"];!ok{
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		indata["expire_at"] = time.Now().Add(({{.ExpireDay}}*24*3600 + 36000+time.Duration(r.Int63n(10800))) * time.Second)
	}else{
		indata["expire_at"] = data["expire_at"]
		delete(data,"expire_at")
	}
	{{end}}	
	err = m.conn.UpSert(ctx, filter, bson.M{"$set": data, "$inc": incdata,"$setOnInsert": indata})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}
func (m *default{{.Type}}Model) UpdateOneByID(ctx context.Context, id string, data bson.M) error {
	oid, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return ErrInvalidObjectId
	}
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOneByID(ctx, id, &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	{{end}}
	data["updated_at"] = time.Now()
	err = m.conn.UpdateOne(ctx, bson.M{"_id": oid}, bson.M{"$set": data})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}
func (m *default{{.Type}}Model) DeleteOne(ctx context.Context, filter any) error {
	var err error
	{{if .Cache}}
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOne(ctx, filter, &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	{{end}}
	err = m.conn.DeleteOne(ctx, filter)
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}
func (m *default{{.Type}}Model) DeleteOneByID(ctx context.Context, id string) error {
	oid, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return ErrInvalidObjectId
	}
	{{if .Cache}}
	
	dataM := bson.M{}
	cacheKeys := []string{}
	err = m.conn.FindOneByID(ctx, id, &dataM)
	if err == nil{
		{{.DelCache}}	
	}
	
	{{end}}
	err = m.conn.DeleteOne(ctx, bson.M{"_id": oid})
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}
func (m *default{{.Type}}Model) DeleteMany(ctx context.Context, filter any) error {
	var err error
	{{if .Cache}}
	cacheKeys := []string{}
	var dataMs []bson.M
	cursor, err := m.conn.FindAllV1(ctx, filter)
	if err == nil {
		defer cursor.Close(ctx)
		for cursor.Next(ctx) {
			item := bson.M{}
			err := cursor.Decode(&item)
			if err != nil {
				var tmp bson.M
				cursor.Decode(&tmp)
				continue
			}
			dataMs = append(dataMs, item)
		}
		go func() {
			for _, dataM := range dataMs {

				cacheKeys = append(cacheKeys, fmt.Sprintf("_id.%v", dataM["_id"].(primitive.ObjectID).Hex()))
				cacheKeys = append(cacheKeys, fmt.Sprintf("payoutRef.%v", dataM["payoutRef"]))
			}
		}()
	}
	{{end}}
	err = m.conn.DeleteMany(ctx, filter)
	{{if .Cache}}
		m.conn.DelCache(ctx,cacheKeys)
	{{end}}
	return err
}
{{.Findfuncs}}
{{.Upfuncs}}
{{.Delfuncs}}
func (m *default{{.Type}}Model)CreateOpIndex(ctx context.Context){
	m.conn.CreatIndexByIndexKey(ctx,{{.lowerType}}OpIndexKey)
}