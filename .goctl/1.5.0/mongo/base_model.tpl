// Code generated by goctl. DO NOT EDIT.
package {{.PKG}}

import (
    "context"
    "fmt"
    "github.com/aiden2048/pkg/public/mongodb"
	"github.com/aiden2048/pkg/qgframe/logs"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)
type Model[T any] struct {
	cache bool
	NeedLog bool
	conn *mongodb.Mon
	data T
}
const (
	RealKey     = mongodb.RealKey     // 运行从库
	RealReadKey = mongodb.RealReadKey // 运行主库
	ConfKey     = mongodb.ConfKey     // 配置从库
	ImageRepositoryKey     = mongodb.ImageRepositoryKey     // 镜像库
	TopKey     = mongodb.TopKey     // top独立库
	LogKey     = mongodb.LogKey     // log库单独实例
)
//default mongodb.RealKey
func (m *Model[T]) SetDbKey(key int8) *Model[T] {
	m.conn.SetDbKey(key)
	return m
}
func (m *Model[T]) GetMon() *mongodb.Mon {
	return m.conn
}
func (m *Model[T]) GetColl() *mongo.Collection {
	return m.conn.GetColl()
}
func (m *Model[T]) GetDbName() string {
	return m.conn.GetDB()
}
func (m *Model[T]) GetTbName() string {
	return m.conn.GetTB()
}
func (m *Model[T]) FindOne(ctx context.Context, filter any) (*T, error) {
	var data T
	err := m.conn.FindOne(ctx, filter, &data)
	switch err {
	case nil:
		return &data, nil
	case mongo.ErrNoDocuments:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *Model[T]) FindOneByID(ctx context.Context, id string) (*T, error) {
	oid, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, ErrInvalidObjectId
	}

	var data T
	if m.cache{
		cacheKey := fmt.Sprintf("_id.%v", id)
		err = m.conn.FindOneByCacheKey(ctx, bson.M{"_id": oid}, cacheKey, &data)
	}else{
		err = m.conn.FindOne(ctx, bson.M{"_id": oid}, &data)
	}
	switch err {
	case nil:
		return &data, nil
	case mongo.ErrNoDocuments:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
func (m *Model[T]) FindMany(ctx context.Context, filter any, sort bson.D, limit int64, selectors ...interface{}) ([]*T, error) {
	cursor, err := m.conn.FindManyV1(ctx, filter, sort, limit, selectors...)
	if err != nil {
		switch err {
		case mongo.ErrNoDocuments:
			return nil, ErrNotFound
		default:
			return nil, err
		}
	}
	defer cursor.Close(ctx)
	data := m.Decode(ctx,cursor,filter)
	return data, nil
}

func (m *Model[T]) FindManyByPage(ctx context.Context, filter any, sort bson.D, page, pageSize int64, selectors ...interface{}) ([]*T, error) {
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	cursor, err := m.conn.FindManyByPageV1(ctx, filter, sort, skip, pageSize, selectors...)
	if err != nil {
		switch err {
		case mongo.ErrNoDocuments:
			return nil, ErrNotFound
		default:
			return nil, err
		}
	}
	defer cursor.Close(ctx)
	data := m.Decode(ctx,cursor,filter)
	return data, nil
}

func (m *Model[T]) FindAll(ctx context.Context, filter any, selectors ...interface{}) ([]*T, error) {
	cursor, err := m.conn.FindAllV1(ctx, filter, selectors...)
	if err != nil {
		switch err {
		case mongo.ErrNoDocuments:
			return nil, ErrNotFound
		default:
			return nil, err
		}
	}
	defer cursor.Close(ctx)
	data := m.Decode(ctx,cursor,filter)
	return data, nil
}
func (m *Model[T]) FindAllBySort(ctx context.Context, filter any, sort bson.D, selectors ...interface{}) ([]*T, error) {
	cursor, err := m.conn.FindAllBySortV1(ctx, filter, sort, selectors...)
	if err != nil {
		switch err {
		case mongo.ErrNoDocuments:
			return nil, ErrNotFound
		default:
			return nil, err
		}
	}
	defer cursor.Close(ctx)
	data := m.Decode(ctx,cursor,filter)
	return data, nil
}
func (m *Model[T]) Decode(ctx context.Context,cursor *mongo.Cursor,filter any)([]*T) {
	var data []*T
	if m.NeedLog{
		logs.PrintInfo("Find Begin",m.GetDbName(),m.GetTbName(),filter)
	}
	n := 0
	for cursor.Next(ctx) {
		var item T
		err := cursor.Decode(&item)
		if err != nil {
			var tmp bson.M
			cursor.Decode(&tmp)
			logs.LogError("数据库结构异常,tb:%s,record:%+v,err:%+v", m.GetTbName(), tmp, err)
			continue
		}
		n++
		data = append(data, &item)
	}
	if m.NeedLog{
		logs.PrintInfo("Find End",m.GetDbName(),m.GetTbName(),filter,n)
	}
	return data
}
func (m *Model[T]) FindCount(ctx context.Context, filter any) (int64, error) {
	return m.conn.FindCount(ctx, filter)
}
func (m *Model[T]) Aggregate(ctx context.Context, pipe []bson.D, opts ...*options.AggregateOptions) ([]bson.M, error) {
	return m.conn.Aggregate(ctx, pipe,opts...)
}

func (m *Model[T]) Sum(ctx context.Context, match any, group any) (bson.M, error) {
	if match == nil {
		match = bson.M{}
	}
	if group == nil {
		group = bson.M{}
	}
	pipeline := mongo.Pipeline{
		{
			{Key:"$match", Value:match},
		},
		{
			{Key:"$group", Value:group},
		},
	}
	ret, err := m.conn.Aggregate(ctx, pipeline)
	if err != nil || len(ret) == 0{
		return bson.M{}, err
	}
	return ret[0], nil
}

func (m *Model[T]) SumMulti(ctx context.Context, match any, group any) ([]bson.M, error) {
	if match == nil {
		match = bson.M{}
	}
	if group == nil {
		group = bson.M{}
	}
	pipeline := mongo.Pipeline{
		{
			{Key:"$match", Value:match},
		},
		{
			{Key:"$group", Value:group},
		},
	}
	ret, err := m.conn.Aggregate(ctx, pipeline)
	if err != nil {
		return []bson.M{}, err
	}
	return ret, nil
}

func (m *Model[T]) Trans(ctx context.Context, fn func(mongo.SessionContext) error) error {
	return m.conn.Trans(ctx, fn)
}
func (m *Model[T]) DeleteIndex(ctx context.Context, indexName string)  error {
	return m.conn.DeleteIndex(ctx, indexName)
}
func (m *Model[T]) CreateIndex(ctx context.Context)  {
	m.conn.CreateIndex(ctx)
}
func (m *Model[T]) CreatIndexByIndexKey(ctx context.Context,indexKey []string)  {
	m.conn.CreatIndexByIndexKey(ctx,indexKey)
}
type defaultBaseModel struct {
	Model[bson.M]
}
func NewBaseModel(db,tb string) *defaultBaseModel {
	conn := mongodb.NewMon(db, tb, false, []string{}, []string{}, []string{})
	model := &defaultBaseModel{}
	model.conn = conn
	model.cache = false
	return model
}